# PMW3610 Optical Mouse Sensor

PMW3610 is a lowâ€‘power optical mouse sensor.

::: note

- Currently, only implemented for nRF52 and RP2040, with a single-wire (SDIO) half-duplex SPI.
- `motion` pin is optional. If omitted, the sensor is polled.

:::

::: warning

Limit report rate to prevent flooding the HID report channel with too many reports, which can cause latency issues especially over BLE. By default, the report rate is 100Hz.
For split keyboards, it is recommended to place the sensor on central rather than peripheral to reduce latency between central and peripheral.

:::

## `toml` configuration

::: warning

`spi.mosi` and `spi.miso` must be the same pin, or one of them empty.

:::

```toml
[[input_device.pmw3610]]
name = "trackball0"

spi.instance = "bitbang0"
spi.sck = "P0_05"
spi.mosi = "P0_04"
spi.miso = "P0_04"
spi.cs = "P0_09"
# or spi = { instance = "bitbang0", sck = "P0_05", mosi = "P0_04", miso = "P0_04", cs = "P0_09" }

motion = "P0_02" # Optional. If omitted, the sensor is polled.

force_awake = false
smart_mode = true
cpi = 800
invert_x = true
# invert_y = true
# swap_xy = true

max_report_hz = 60 # Optional. Maximum report rate in Hz (default: 100Hz)
```

## Rust configuration

Define `Pmw3610Device` and add it to `run_devices!` macro.

```rust
let pmw3610_config = Pmw3610Config {
    res_cpi: 800,
    // force_awake: true,
    smart_mode: true,
    swap_xy: true,
    // invert_x: true,
    // invert_y: true,
    ..Default::default()
};

let pmw3610_sck = Output::new(p.P0_05, Level::High, OutputDrive::Standard);
let pmw3610_sdio = Flex::new(p.P0_04);
let pmw3610_cs = Output::new(p.P0_09, Level::High, OutputDrive::Standard);
let pmw3610_motion = Some(Input::new(p.P0_02, Pull::Up));
// or if you want to omit the motion pin:
// let pmw3610_motion = Option::<Input<'static>>::None;

let pmw3610_spi = BitBangSpiBus::new(pmw3610_sck, pmw3610_sdio);

let mut pmw3610_device = Pmw3610Device::new(
    pmw3610_spi,
    pmw3610_cs,
    pmw3610_motion,
    pmw3610_config,
);

run_devices! (
    (matrix, pmw3610_device) => EVENT_CHANNEL,
),
```

And define a `Pmw3610Processor` and run its `polling_loop()` alongside RMK to process the events.

::: warning

This should be added to the central if the sensor is on split peripheral.

:::

```rust
use rmk::input_device::pmw3610::Pmw3610Processor;
use rmk::controller::PollingController;

// Default report rate (100Hz)
let mut pmw3610_processor = Pmw3610Processor::new(&keymap);

// Or with custom report rate:
// let mut pmw3610_processor = Pmw3610Processor::with_report_hz(&keymap, 60);

// Run the processor's polling loop alongside RMK
embassy_futures::join::join(
    pmw3610_processor.polling_loop(),
    run_rmk(
        // ... other arguments
    ),
)
.await;
```
